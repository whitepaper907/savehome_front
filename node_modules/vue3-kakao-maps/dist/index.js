import { ref as b, defineComponent as _, provide as W, onMounted as z, watch as v, computed as S, openBlock as p, createElementBlock as M, normalizeStyle as j, Fragment as K, renderList as I, createBlock as w, unref as y, createCommentVNode as L, renderSlot as C, toRaw as T, inject as P, onBeforeUnmount as E, withCtx as F } from "vue";
const m = b(!1), Y = (g, k) => {
  const i = document.createElement("script"), e = k != null && k.length > 0 ? `&libraries=${k.join(",")}` : "";
  i.id = "kakao-map-api-script", i.src = `//dapi.kakao.com/v2/maps/sdk.js?appkey=${g}&autoload=false${e}`, document.body.appendChild(i), i.onload = () => {
    kakao.maps.load(() => {
      m.value = !0;
    });
  };
}, G = /* @__PURE__ */ _({
  __name: "KakaoMap",
  props: {
    width: { default: "40rem" },
    height: { default: "30rem" },
    markerList: {},
    infoWindowList: {},
    markerCluster: {},
    lat: {},
    lng: {},
    level: { default: 3 },
    mapTypeId: {},
    draggable: { type: Boolean, default: !0 },
    scrollwheel: { type: Boolean, default: !0 },
    disableDoubleClick: { type: Boolean, default: !1 },
    disableDoubleClickZoom: { type: Boolean, default: !1 },
    projectionId: { default: "kakao.maps.ProjectionId.WCONG" },
    tileAnimation: { type: Boolean, default: !0 },
    keyboardShortcuts: { type: [Boolean, Object] }
  },
  emits: ["onLoadKakaoMap"],
  setup(g, { emit: k }) {
    const i = g, e = k, a = b(null), d = b();
    W("mapRef", d);
    const u = () => {
      const l = {
        center: new kakao.maps.LatLng(i.lat, i.lng),
        ...i
      };
      a.value !== null && (d.value = new window.kakao.maps.Map(a.value, l), e("onLoadKakaoMap", d.value));
    }, h = b(), r = (l) => {
      if (l.markers === void 0)
        throw new Error("MarkerList가 없습니다.");
      if (d.value !== null) {
        const s = b([]);
        l.markers.forEach((t) => {
          var c;
          const n = new kakao.maps.Marker({
            position: new kakao.maps.LatLng(t.lat, t.lng),
            image: t.image ?? void 0,
            title: t.title ?? void 0,
            draggable: typeof t.draggable == "boolean" ? t.draggable : !1,
            clickable: typeof t.clickable == "boolean" ? t.clickable : !1,
            zIndex: typeof t.zIndex == "number" ? t.zIndex : 0,
            opacity: t.opacity ?? 1,
            altitude: t.altitude ?? 0,
            range: t.range ?? void 0
          });
          (c = s.value) == null || c.push(n);
        }), h.value = new kakao.maps.MarkerClusterer({
          map: T(d.value),
          ...l,
          markers: s.value
        });
      }
    };
    z(() => {
      m.value && (u(), i.markerCluster !== void 0 && r(i.markerCluster));
    }), v(
      () => m.value,
      (l) => {
        l && (u(), i.markerCluster !== void 0 && r(i.markerCluster));
      }
    );
    const o = S(() => ({
      width: isFinite(+i.width) ? i.width + "px" : i.width,
      height: isFinite(+i.height) ? i.height + "px" : i.height
    }));
    return v([() => i.lat, () => i.lng], ([l, s]) => {
      var t;
      (t = d.value) == null || t.panTo(new kakao.maps.LatLng(l, s));
    }), v(
      () => i.draggable,
      (l) => {
        var s, t;
        l === void 0 || l ? (s = d.value) == null || s.setDraggable(!0) : (t = d.value) == null || t.setDraggable(!1);
      }
    ), v(
      () => i.level,
      (l) => {
        var s, t;
        l === void 0 ? (s = d.value) == null || s.setLevel(3) : (t = d.value) == null || t.setLevel(l);
      }
    ), v(
      () => i.mapTypeId,
      (l) => {
        var s, t;
        l === void 0 ? (s = d.value) == null || s.setMapTypeId(3) : (t = d.value) == null || t.setMapTypeId(l);
      }
    ), v(
      () => i.scrollwheel,
      (l) => {
        var s, t;
        l === void 0 ? (s = d.value) == null || s.setZoomable(!0) : (t = d.value) == null || t.setZoomable(l);
      }
    ), v(
      () => i.projectionId,
      (l) => {
        var s, t;
        l === void 0 ? (s = d.value) == null || s.setProjectionId(kakao.maps.ProjectionId.WCONG) : (t = d.value) == null || t.setProjectionId(l);
      }
    ), v(
      () => i.keyboardShortcuts,
      (l) => {
        var s, t;
        l === void 0 ? (s = d.value) == null || s.setKeyboardShortcuts(!1) : typeof l == "boolean" && ((t = d.value) == null || t.setKeyboardShortcuts(l));
      }
    ), (l, s) => (p(), M("div", {
      ref_key: "kakaoMapRef",
      ref: a,
      style: j(o.value)
    }, [
      i.markerList && i.markerCluster === void 0 ? (p(!0), M(K, { key: 0 }, I(i.markerList, (t, n) => (p(), w(y(B), {
        key: t.key === void 0 ? n : t.key,
        lat: t.lat,
        lng: t.lng,
        "info-window": t == null ? void 0 : t.infoWindow,
        draggable: t.draggable,
        image: t.image,
        order: t.order,
        "order-bottom-margin": t.orderBottomMargin
      }, null, 8, ["lat", "lng", "info-window", "draggable", "image", "order", "order-bottom-margin"]))), 128)) : L("", !0),
      i.infoWindowList ? (p(!0), M(K, { key: 1 }, I(i.infoWindowList, (t, n) => (p(), w(y(O), {
        key: t.key === void 0 ? n : t.key,
        lat: t.lat,
        lng: t.lng,
        content: t.content,
        visible: t.visible
      }, null, 8, ["lat", "lng", "content", "visible"]))), 128)) : L("", !0),
      C(l.$slots, "default")
    ], 4));
  }
}), Z = 30, H = 30, N = {
  imageSrc: "https://t1.daumcdn.net/mapjsapi/images/2x/marker.png",
  imageWidth: 29,
  imageHeight: 42,
  imageOption: {}
}, B = /* @__PURE__ */ _({
  __name: "KakaoMapMarker",
  props: {
    lat: {},
    lng: {},
    infoWindow: {},
    visible: { type: Boolean },
    image: {},
    title: {},
    draggable: { type: Boolean },
    clickable: { type: Boolean },
    zIndex: {},
    opacity: {},
    altitude: {},
    range: {},
    order: {},
    orderBottomMargin: {}
  },
  emits: [
    "onLoadKakaoMapMarker",
    "onClickKakaoMapMarker",
    "dragEndKakaoMapMarker",
    "mouseOverKakaoMapMarker",
    "mouseOutKakaoMapMarker",
    "deleteKakaoMapMarker"
  ],
  setup(g, { emit: k }) {
    const i = k, e = g, a = b(), d = P("mapRef"), u = (n) => {
      if (n != null) {
        if (n.imageSrc === void 0)
          throw new Error("이미지 경로가 존재하지 않습니다.");
      } else
        n = N;
      const c = new kakao.maps.MarkerImage(
        n.imageSrc,
        new kakao.maps.Size(n.imageWidth ?? Z, n.imageHeight ?? H),
        n.imageOption
      );
      a.value !== void 0 && a.value.setImage(c);
    }, h = (n) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("marker의 위치가 없습니다.");
      const c = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.Marker({
        position: c,
        title: e.title,
        draggable: e.draggable,
        clickable: e.clickable,
        zIndex: e.zIndex,
        opacity: e.opacity,
        altitude: e.altitude,
        range: e.range
      }), u(e.image), i("onLoadKakaoMapMarker", a.value), a.value.setMap(n), r(a.value), l(a.value), s(a.value), o(n, a.value);
    }, r = (n) => {
      kakao.maps.event.addListener(n, "click", () => {
        i("onClickKakaoMapMarker");
      });
    }, o = (n, c) => {
      kakao.maps.event.addListener(c, "dragend", function(f) {
        i("dragEndKakaoMapMarker", c);
      });
    }, l = (n) => {
      kakao.maps.event.addListener(n, "mouseover", () => {
        i("mouseOverKakaoMapMarker");
      });
    }, s = (n) => {
      kakao.maps.event.addListener(n, "mouseout", () => {
        i("mouseOutKakaoMapMarker");
      });
    }, t = (n) => `<div style="position:relative; bottom:${e.orderBottomMargin}">
        ${n}
      </div>`;
    return E(() => {
      var n;
      i("deleteKakaoMapMarker", a), (n = a.value) == null || n.setMap(null);
    }), v(
      [() => m.value, () => d, () => d == null ? void 0 : d.value],
      ([n, c, f]) => {
        n && c !== void 0 && f !== void 0 && h(f);
      },
      { immediate: !0 }
    ), v([() => e.lat, () => e.lng], ([n, c]) => {
      var f;
      m.value && ((f = a.value) == null || f.setPosition(new kakao.maps.LatLng(n, c)));
    }), v([() => e.image], () => {
      u(e.image);
    }), v(
      () => e.title,
      (n) => {
        var c;
        n !== void 0 && ((c = a.value) == null || c.setTitle(n));
      }
    ), v(
      () => e.draggable,
      (n) => {
        var c;
        (c = a.value) == null || c.setDraggable(n !== void 0 && n);
      }
    ), v(
      () => e.clickable,
      (n) => {
        var c;
        (c = a.value) == null || c.setDraggable(n !== void 0 && n);
      }
    ), v(
      () => e.zIndex,
      (n) => {
        var c;
        n !== void 0 && isFinite(n) && ((c = a.value) == null || c.setZIndex(Number(n)));
      }
    ), v(
      () => e.opacity,
      (n) => {
        var c, f;
        n !== void 0 && isFinite(n) ? (c = a.value) == null || c.setOpacity(Number(n)) : (f = a.value) == null || f.setOpacity(1);
      }
    ), (n, c) => {
      var f, A, x;
      return p(), M("div", null, [
        n.$slots.infoWindow ? (p(), w(y(O), {
          key: 0,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          visible: (f = e == null ? void 0 : e.infoWindow) == null ? void 0 : f.visible
        }, {
          default: F(() => [
            C(n.$slots, "infoWindow")
          ]),
          _: 3
        }, 8, ["marker", "lat", "lng", "visible"])) : e.infoWindow ? (p(), w(y(O), {
          key: 1,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          content: (A = e == null ? void 0 : e.infoWindow) == null ? void 0 : A.content,
          visible: (x = e == null ? void 0 : e.infoWindow) == null ? void 0 : x.visible
        }, null, 8, ["marker", "lat", "lng", "content", "visible"])) : L("", !0),
        e.order ? (p(), w(y($), {
          key: 2,
          lat: e.lat,
          lng: e.lng,
          "y-anchor": 0,
          content: t(e.order)
        }, null, 8, ["lat", "lng", "content"])) : L("", !0)
      ]);
    };
  }
}), U = { key: 0 }, O = /* @__PURE__ */ _({
  __name: "KakaoMapInfoWindow",
  props: {
    lat: {},
    lng: {},
    marker: {},
    content: {},
    disableAutoPan: { type: Boolean },
    removable: { type: Boolean, default: !1 },
    zIndex: {},
    altitude: {},
    range: { default: 500 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapInfoWindow"],
  setup(g, { emit: k }) {
    const i = k, e = g, a = b(), d = b(), u = P("mapRef"), h = (r) => {
      var l, s;
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("infoWindow의 위치가 없습니다.");
      const o = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.InfoWindow({
        position: o,
        content: d.value ?? e.content ?? "",
        removable: e.removable,
        disableAutoPan: e.disableAutoPan,
        zIndex: e.zIndex,
        altitude: e.altitude,
        range: e.range
      }), e.visible && (i("onLoadKakaoMapInfoWindow", a.value), e.marker !== void 0 ? (l = a == null ? void 0 : a.value) == null || l.open(r, e.marker) : (s = a == null ? void 0 : a.value) == null || s.open(r));
    };
    return E(() => {
      (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
    }), v(
      [() => m.value, () => u == null ? void 0 : u.value, () => m, () => u],
      ([r, o]) => {
        e.visible && r && o !== void 0 && o !== null && h(o);
      },
      { immediate: !0 }
    ), v(
      () => e.marker,
      (r) => {
        var o, l, s;
        !e.visible || (u == null ? void 0 : u.value) === void 0 || (a.value != null && ((o = a.value) == null || o.close()), r !== void 0 ? (l = a == null ? void 0 : a.value) == null || l.open(u == null ? void 0 : u.value, r) : (s = a == null ? void 0 : a.value) == null || s.open(u == null ? void 0 : u.value));
      },
      {
        immediate: !0
      }
    ), v(
      [() => d == null ? void 0 : d.value, () => d],
      ([r, o]) => {
        var l;
        r !== void 0 && ((l = a.value) == null || l.setContent(r));
      },
      { deep: !0 }
    ), v([() => e.lat, () => e.lng], ([r, o]) => {
      var l;
      (l = a.value) == null || l.setPosition(new kakao.maps.LatLng(r, o));
    }), v(
      () => e.content,
      (r) => {
        var o;
        (o = a.value) == null || o.setContent(r ?? "");
      }
    ), v(
      () => e.zIndex,
      (r) => {
        var o;
        (o = a.value) == null || o.setZIndex(r ?? 0);
      }
    ), v(
      () => e.altitude,
      (r) => {
        var o;
        (o = a.value) == null || o.setAltitude(r ?? 0);
      }
    ), v(
      () => e.range,
      (r) => {
        var o;
        (o = a.value) == null || o.setRange(r ?? 500);
      }
    ), v(
      () => e.visible,
      (r) => {
        r ? m != null && m.value && (u == null ? void 0 : u.value) !== void 0 && (u == null ? void 0 : u.value) !== null && h(u.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
      }
    ), (r, o) => e.content && e.content.length > 0 || r.$slots.default ? (p(), M("div", U, [
      r.$slots.default ? (p(), M("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: d
      }, [
        C(r.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), V = { key: 0 }, $ = /* @__PURE__ */ _({
  __name: "KakaoMapCustomOverlay",
  props: {
    lat: {},
    lng: {},
    content: {},
    xAnchor: { default: 0.5 },
    yAnchor: { default: 0.5 },
    zIndex: {},
    clickable: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapCustomOverlay"],
  setup(g, { emit: k }) {
    const i = k, e = g, a = b(), d = b(), u = P("mapRef"), h = (r) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("KakaoMapCustomOverlay의 위치가 없습니다.");
      const o = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.CustomOverlay({
        position: o,
        content: d.value ?? e.content ?? "",
        xAnchor: e.xAnchor,
        yAnchor: e.yAnchor,
        zIndex: e.zIndex,
        clickable: e.clickable
      }), e.visible && (a.value.setMap(r), i("onLoadKakaoMapCustomOverlay", a.value));
    };
    return E(() => {
      var r;
      a.value !== null && ((r = a.value) == null || r.setMap(null));
    }), v(
      [() => m.value, () => u == null ? void 0 : u.value, () => m, () => u],
      ([r, o]) => {
        e.visible && r && o !== void 0 && o !== null && h(o);
      },
      { immediate: !0 }
    ), v([() => e.lat, () => e.lng], ([r, o]) => {
      var l;
      (l = a.value) == null || l.setPosition(new kakao.maps.LatLng(r, o));
    }), v(
      () => e.content,
      (r) => {
        var o;
        (o = a.value) == null || o.setContent(r ?? "");
      }
    ), v(
      () => e.zIndex,
      (r) => {
        var o;
        (o = a.value) == null || o.setZIndex(r ?? 0);
      }
    ), v(
      () => e.visible,
      (r) => {
        var o;
        r ? m != null && m.value && (u == null ? void 0 : u.value) !== void 0 && (u == null ? void 0 : u.value) !== null && h(u.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && ((o = a.value) == null || o.setMap(null));
      }
    ), (r, o) => e.content && e.content.length > 0 || r.$slots.default ? (p(), M("div", V, [
      r.$slots.default ? (p(), M("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: d
      }, [
        C(r.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), D = /* @__PURE__ */ _({
  __name: "KakaoMapPolyline",
  props: {
    linePath: {},
    endArrow: { type: Boolean },
    strokeWeight: { default: 3 },
    strokeColor: { default: "#F10000" },
    strokeOpacity: { default: 0.6 },
    strokeStyle: { default: "solid" },
    zIndex: {}
  },
  setup(g) {
    const k = g, i = P("mapRef");
    let e = null;
    const a = (d) => {
      e = new kakao.maps.Polyline({
        path: k.linePath,
        endArrow: k.endArrow,
        strokeWeight: k.strokeWeight,
        strokeColor: k.strokeColor,
        strokeOpacity: k.strokeOpacity,
        strokeStyle: k.strokeStyle,
        zIndex: k.zIndex
      }), e.setMap(d);
    };
    return v(
      [() => m.value, () => i == null ? void 0 : i.value, () => m, () => i],
      ([d, u]) => {
        d && u !== void 0 && u !== null && a(u);
      },
      { immediate: !0 }
    ), v(
      () => k.linePath,
      () => {
        e == null || e.setPath(k.linePath);
      },
      { deep: !0 }
    ), E(() => {
      e == null || e.setMap(null);
    }), (d, u) => (p(), M("div", null, [
      C(d.$slots, "default")
    ]));
  }
}), q = { key: 0 }, J = { key: 1 }, Q = /* @__PURE__ */ _({
  __name: "KakaoMapMarkerPolyline",
  props: {
    markerList: {},
    endArrow: { type: Boolean },
    strokeWeight: {},
    strokeColor: {},
    strokeOpacity: {},
    strokeStyle: {},
    showMarkerOrder: { type: Boolean }
  },
  setup(g) {
    const k = g, i = P("mapRef");
    let e;
    const a = b([]), d = (o) => {
      a.value.push(o);
    }, u = (o) => {
      const l = a.value.indexOf(o);
      a.value.splice(l, 1);
    }, h = (o) => {
      const l = k.markerList, s = a.value.indexOf(o);
      l[s].lat = o.getPosition().getLat(), l[s].lng = o.getPosition().getLng();
    }, r = (o, l) => `<div style="position:relative; bottom:${l}">
        ${o}
      </div>`;
    return z(() => {
      e = S(() => k.markerList.map((o) => new kakao.maps.LatLng(o.lat, o.lng)));
    }), (o, l) => (p(), M(K, null, [
      k.markerList && y(i) !== null ? (p(), M("div", q, [
        (p(!0), M(K, null, I(k.markerList, (s, t) => (p(), w(y(B), {
          id: t,
          key: s.key === void 0 ? t : s.key,
          map: y(i),
          lat: s.lat,
          lng: s.lng,
          draggable: s.draggable,
          image: s.image,
          onOnLoadKakaoMapMarker: d,
          onDragEndKakaoMapMarker: h,
          onDeleteKakaoMapMarker: u
        }, null, 8, ["id", "map", "lat", "lng", "draggable", "image"]))), 128)),
        (p(!0), M(K, null, I(y(e), (s, t) => (p(), M("div", { key: t }, [
          t !== y(e).length - 1 ? (p(), w(y(D), {
            key: 0,
            linePath: [s, y(e)[t + 1]],
            endArrow: k.endArrow
          }, null, 8, ["linePath", "endArrow"])) : L("", !0)
        ]))), 128))
      ])) : L("", !0),
      k.markerList && k.showMarkerOrder ? (p(), M("div", J, [
        (p(!0), M(K, null, I(k.markerList, (s, t) => (p(), w(y($), {
          key: t,
          lat: s.lat,
          lng: s.lng,
          "y-anchor": 0,
          content: r(s.order !== void 0 ? s.order : t, s.orderBottomMargin)
        }, null, 8, ["lat", "lng", "content"]))), 128))
      ])) : L("", !0),
      C(o.$slots, "default")
    ], 64));
  }
}), R = {
  install: (g) => {
    g.component("KakaoMap", G), g.component("KakaoMapMarker", B), g.component("KakaoMapCustomOverlay", $), g.component("KakaoMapInfoWindow", O), g.component("KakaoMapMarkerPolyline", Q), g.component("KakaoMapPolyline", D);
  }
};
export {
  G as KakaoMap,
  $ as KakaoMapCustomOverlay,
  O as KakaoMapInfoWindow,
  B as KakaoMapMarker,
  Q as KakaoMapMarkerPolyline,
  D as KakaoMapPolyline,
  R as Vue3KakaoMaps,
  m as isKakaoMapApiLoaded,
  Y as useKakao
};
